http://coding.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/“Don’t call us, we’ll call you”- load, domready, click, change, focus, blur, keyup, itd.- touch !!<a href="" onclick="alert(1);" $('a').onclick = function() {};target.addEventListener(type, listener[, useCapture]);capturing vs. bubblingaddEventListener   (attachEvent)// Function to change the content of t2function modifyText() {  var t2 = document.getElementById("t2");  if (t2.firstChild.nodeValue == "three") {    t2.firstChild.nodeValue = "two";  } else {    t2.firstChild.nodeValue = "three";  }}// add event listener to tvar el = document.getElementById("outside");el.addEventListener("click", modifyText, false);https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListeneraddEventListener is the way to register an event listener as specified in W3C DOM. Its benefits are as follows:    It allows adding more than a single handler for an event. This is particularly useful for DHTML libraries or Mozilla extensions that need to work well even if other libraries/extensions are used.    It gives you finer-grained control of the phase when the listener gets activated (capturing vs. bubbling)    It works on any DOM element, not just HTML elements.	Legacy Internet Explorer and attachEvent (<IE9)if (el.addEventListener) {  el.addEventListener('click', modifyText, false); } else if (el.attachEvent)  {  el.attachEvent('onclick', modifyText);}removeEventListenerEvent.preventDefaultEvent.stopPropagationdocument.addEventListener( "DOMContentLoaded", function(){	document.removeEventListener( "DOMContentLoaded", arguments.callee, false );	jQuery.ready();}, false );<body onload=  window.addEventListener("load", function load(event){Most used events<a id="example-1" href=""<select id="example-2" name="city">	<option value="OS">Osijek</option>	<option value="NY">New York</option></select><input id="example-3" type="text" value="Enter search term" />SEPERATE TOUCH EXAMPLE ( show in chrome )http://www.quirksmode.org/js/introevents.htmlhttp://www.quirksmode.org/js/events_order.htmlTwo modelsNot surprisingly, back in the bad old days Netscape and Microsoft came to different conclusions.    Netscape said that the event on element1 takes place first. This is called event capturing.    Microsoft maintained that the event on element2 takes precedence. This is called event bubbling.The two event orders are radically opposed. Explorer only supports event bubbling. Mozilla, Opera 7 and Konqueror support both. Older Opera's and iCab support neither.for (i in window) {  if ( /^on/.test(i)) { out[out.length] = i; }}log.innerHTML = out.join(', ');transition!!!  events			https://developer.mozilla.org/samples/domref/dispatchEvent.htmlhttps://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_transitions<!--h3>Event listeners and Registry pattern</h3><pre>There are several practical problems with native event listeners. We can't get list of event listeners registered with addEventListener from Element itself. Get all functions associated with element click for example in attempt to remove them all. Also, we can't manipulate execution order, register one listener to run before already registered listener.But you probbaly noticed that this works in some libraries (off(), stopObserving(), click(), etc.)If youQ: Can we get list of all event listeners registered with addEventListener, all functions associated to element click for example? A: Unfortunately no.Q: Can we change order of their execution? Register one listener to run before already registered listener?A: Unfortunately no.Q: Can we remove listener somehow without handle?No from outside, yes from inside of listener itself when it's triggered. Check example in "Dom Ready" section above.Q: But all of this work in some libraries (off(), stopObserving(), click(), etc.) ?A: When you add listener with Element.observe('click', fnc) in prototype.js for example, Prototype is pushing your listener to its internal registry array, and associating it's own function to handle 'click'. When acctual click happen, Prototypes function is really triggered, and that function trigger your functions from internal stack.This is called event registry pattern and the idea is to solve above problems. This is also why it is so easy to just run click() in jQuery.Ofc, the only way for this to work in libraries is to use libraries observe(),click(),bind(),etc instead of native addEventListener().All mentioned problems can be solved with restructuring code a bit in most cases.http://stackoverflow.com/a/447106(thx Matej for great questions)</pre-->